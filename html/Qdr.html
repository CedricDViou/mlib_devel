<!-- start content -->
			<p><b>Block:</b> QDR (<code>qdr</code>)<br />
<b>Block Author</b>: David George<br />
<b>Document Author</b>: David George<br />
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Summary"><span class="tocnumber">1</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Mask_Parameters"><span class="tocnumber">2</span> <span class="toctext">Mask Parameters</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Ports"><span class="tocnumber">3</span> <span class="toctext">Ports</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Description"><span class="tocnumber">4</span> <span class="toctext">Description</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Issuing_Commands"><span class="tocnumber">4.1</span> <span class="toctext">Issuing Commands</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Bursting"><span class="tocnumber">4.2</span> <span class="toctext">Bursting</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Addressing"><span class="tocnumber">4.3</span> <span class="toctext">Addressing</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#ECC_Bits"><span class="tocnumber">4.4</span> <span class="toctext">ECC Bits</span></a></li>
</ul>
</li>
</ul>
</td></tr></table><script>if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<h2> <span class="mw-headline" id="Summary"> Summary </span></h2>
<p>This block interfaces to the QDR SRAM devices on ROACH boards. Commands are executed at the rate they are applied, with synchronous and fixed timing. Data is always presented 10 cycles after a read is issued. Read and write data ports have 100% duty cycles.
</p>
<h2> <span class="mw-headline" id="Mask_Parameters"> Mask Parameters </span></h2>
<table width="500" border="1" cellpadding="3">
<tr>
<th> Parameter
</th><th> Variable
</th><th> Description
</th></tr>
<tr>
<td> QDR Chip
</td><td> which_qdr
</td><td> Selects which physical QDR device to use (Two on ROACH V1).
</td></tr>
<tr>
<td> Simulation QDR Address Width
</td><td> qdr_awidth
</td><td> Specifies the width of the address bus of the simulation model. (Limited to 18)
</td></tr>
<tr>
<td> Use CPU Interface
</td><td> use_cpu
</td><td> Specify whether or not to include the QDR CPU interface, the removal of which may improve timing performance.
</td></tr>
</table>
<h2> <span class="mw-headline" id="Ports"> Ports </span></h2>
<table width="500" border="1" cellpadding="3">
<tr>
<th> Port
</th><th> Dir
</th><th> Data Type
</th><th> Description
</th></tr>
<tr>
<td> rd_en
</td><td> in
</td><td> boolean
</td><td> Asserting this signal issues a read command. See below for details on issuing commands.
</td></tr>
<tr>
<td> wr_en
</td><td> in
</td><td> boolean
</td><td> Asserting this signal issues a write command. See below for details on issuing commands.
</td></tr>
<tr>
<td> be
</td><td> in
</td><td> UFix_4
</td><td> Selects bytes for writing (write byte enable). See below for behaviour relating to bursting and ECC bits.
</td></tr>
<tr>
<td> address
</td><td> in
</td><td> UFix_32
</td><td> Signal used as the QDR address. See below for behaviour relating to addressing.
</td></tr>
<tr>
<td> wr_data
</td><td> out
</td><td> UFix_36
</td><td> The data to written into the QDR. Bits 35:32 are ECC bits and are cleared when the processor writes to the corresponding byte. See below for behaviour relating to bursting and ECC bits.
</td></tr>
<tr>
<td> data_valid
</td><td> out
</td><td> boolean
</td><td> An active high signal indicating that the read data is valid.
</td></tr>
<tr>
<td> ack
</td><td> out
</td><td> boolean
</td><td> A signal indicating that the CPU interface is not accessing the memory.
</td></tr>
<tr>
<td> phy_ready
</td><td> out
</td><td> boolean
</td><td> A signal indicating that the QDR PHY has completed calibration, which takes very roughly 100us.
</td></tr>
<tr>
<td> cal_fail
</td><td> out
</td><td> boolean
</td><td> A signal indicating that the PHY calibration has failed.
</td></tr>
</table>
<h2> <span class="mw-headline" id="Description"> Description </span></h2>
<p>This document is a draft and requires verification.
</p>
<h4> <span class="mw-headline" id="Issuing_Commands"> Issuing Commands </span></h4>
<p>There are two types of commands: reads and writes. They are issued by the rd_en and wr_en signals respectively. The QDR address is presented on the same cycle that the command is issues. One type of command cannot be issued in two consecutive cycles. When this happens, the second issue will be ignored. This is due to QDR supporting bursts to reduce data rates on the control signals. Further, if a read and write are issued at the same time the write will be ignored. However, if the previous command was a valid read, the current read will be ignored and the write will take preference.
</p>
<h4> <span class="mw-headline" id="Bursting"> Bursting </span></h4>
<p>When issuing reads and writes, data is presented on the respective data ports for two cycles. When issuing a write command, the <tt>data_in</tt> and <tt>be</tt> ports must be set for both the issuing cycle and the following cycle. During a read response, data is issued on the same cycle that the data_valid is asserted and on the following cycle.
</p>
<h4> <span class="mw-headline" id="Addressing"> Addressing </span></h4>
<p>The address presented when a command is issued addresses a full burst worth of memory i.e. 72 bits of data.
</p>
<h4> <span class="mw-headline" id="ECC_Bits"> ECC Bits </span></h4>
<p>In hardware the QDR word is composed of four 9 bit components which are masked by the byte_enable signal. Each of these component include 8 data bits and a single ECC bit. This clashes with the byte-enable on the processor, which mask only 8 bits. For this reason the ECC bit gets cleared when the CPU writes to a byte of QDR memory. With this yellow block, the QDR data_in and data_out ports have the ECC bits on lines 35:32. This allows the four processor bytes to cleanly map to bits 31:0 of the data_in and data_out ports. This leads to a side-effect in the byte-enable behaviour as follows: be[0] masks data_in bits [7:0] and [32], be[1] mask data_in bits[15:8] and [33] etcetera.
</p>