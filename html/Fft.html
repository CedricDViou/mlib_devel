<!-- start content -->
			<p><b>Block:</b> FFT (<code>fft</code>)<br />
<b>Block Author</b>: Aaron Parsons<br />
<b>Block Maintainer</b>: Andrew Martens<br />
<b>Document Author</b>: Aaron Parsons, Andrew Martens<br />
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Summary"><span class="tocnumber">1</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Mask_Parameters"><span class="tocnumber">2</span> <span class="toctext">Mask Parameters</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Ports"><span class="tocnumber">3</span> <span class="toctext">Ports</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Description"><span class="tocnumber">4</span> <span class="toctext">Description</span></a></li>
</ul>
</td></tr></table><script>if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<h2> <span class="mw-headline" id="Summary"> Summary </span></h2>
<p>Computes the Fast Fourier Transform with <span class="texhtml">2<sup><i>N</i></sup></span> channels for time samples presented <span class="texhtml">2<sup><i>P</i></sup></span> at a time in parallel.  Uses a biplex FFT architecture under the hood which has been extended to handled time samples in parallel.  For <span class="texhtml"><i>P</i> = 0</span>, this block accepts two independent, parallel streams (labelled as pols) and computes the FFT of each independently (the biplex architecture provides this for free).  Data is output in normal frequency order, meaning that channel 0 (corresponding to DC) is output first, followed by channel 1, on up to channel <span class="texhtml">2<sup><i>N</i></sup> &minus; 1</span> (which can be interpreted as channel -1).  When multiple time samples are presented in parallel on the input, multiple frequency samples are output in parallel.
</p>
<h2> <span class="mw-headline" id="Mask_Parameters"> Mask Parameters </span></h2>
<table width="1500" border="1" cellpadding="3">
<tr>
<th> Parameter
</th><th> Variable
</th><th> Description
</th><th> Recommended Value
</th></tr>

<tr>
<td> Number simultaneous streams
</td><td> n_streams
</td><td> The number of input data streams to be processed in parallel. Each stream consists of a set of parallel inputs set by another parameter (see Number of Simultaneous Inputs)
</td><td>
</td></tr>
<tr>
<td> Size of FFT: (2^?)
</td><td> FFTSize
</td><td> The number of channels computed in the complex FFT core.  The number of channels output for each real stream is half of this.
</td><td>
</td></tr>
<tr>
<td> Input Bit Width
</td><td> input_bit_width
</td><td> The number of bits in each real and imaginary sample as they are carried through the FFT.  Each FFT stage will round numbers back down to this number of bits after performing a butterfly computation if bit growth is not enabled.
</td><td> To make optimal use of BRAM =&gt; 18
<p>For low FFT noise =&gt; 25
</p>
</td></tr>
<tr>
<td> Input binary point
</td><td> bin_pt
</td><td> The position of the binary point in the input data.
</td><td>
</td></tr>
<tr>
<td> Coefficient Bit Width
</td><td> coeff_bit_width
</td><td> The number of bits used in the real and imaginary part of the twiddle factors at each stage.
</td><td> 18
</td></tr>
<tr>
<td> Number of Simultaneous Inputs: (2^?)
</td><td> n_inputs
</td><td> The number of parallel time samples which are presented to the FFT core each clock.  This must be at least <span class="texhtml">2<sup>2</sup></span>.  The number of output ports is half of this value.
</td><td>
</td></tr>
<tr>
<td> Unscramble output (ie, put channels in canonical order)
</td><td> unscramble
</td><td> The FFT inherently produces data in an order that requires unscrambling before being used by many algorithms. This requires resources and can limit performance and so should be disabled if not necessary.
</td><td>
</td></tr>
<tr>
<td> Asynchronous operation
</td><td> async
</td><td> Whether valid data is input on every clock cycle or is flagged via the en input port.
</td><td>
</td></tr>
<tr>
<td> Quantization Behavior
</td><td> quantization
</td><td> Specifies the rounding behavior used at the end of each twiddle and butterfly computation to return to the number of bits specified above.
</td><td> NOT Truncate.
</td></tr>
<tr>
<td> Overflow Behavior
</td><td> overflow
</td><td> Indicates the behavior of the FFT core when the value of a sample exceeds what can be expressed in the specified bit width.
</td><td> Wrap as Saturate will not make overflow corruption better behaved.
</td></tr>
<tr>
<td> Add Latency
</td><td> add_latency
</td><td> Latency through adders in the FFT.
</td><td> 1
</td></tr>
<tr>
<td> Mult Latency
</td><td> mult_latency
</td><td> Latency through multipliers in the FFT.
</td><td> 2
</td></tr>
<tr>
<td> BRAM Latency
</td><td> bram_latency
</td><td> Latency through BRAM in the FFT.
</td><td> 2 For designs aimed at &gt; 200MHz =&gt; 3
</td></tr>
<tr>
<td> Convert Latency
</td><td> conv_latency
</td><td> Latency through blocks used to reduce bit widths after twiddle and butterfly stages.
</td><td> 1 For designs aimed at &gt; 180Mhz =&gt; 2
</td></tr>
<tr>
<td> Number bits above which to store stage's coefficients in BRAM (2^? bits)
</td><td> coeffs_bit_limit
</td><td> Determines the threshold at which the twiddle coefficients in a stage are stored in BRAM. Below this threshold distributed RAM is used.
</td><td> 8 (ensures at least 2^8=256 bits out of 18432 bits of BRAM used)
</td></tr>
<tr>
<td> Number bits above which to implement stage's delays in BRAM (2^? bits)
</td><td> delays_bit_limit
</td><td> Determines the threshold at which data delays in a stage are stored in BRAM. Below this threshold distributed RAM is used.
</td><td> 8 (ensures at least 2^8=256 bits out of 18432 bits of BRAM used)
</td></tr>
<tr>
<td> BRAM sharing in coeff storage
</td><td> coeff_sharing
</td><td> Real and imaginary components of twiddle factors can be generated from the same set of coefficients, reducing BRAM use at the cost of some logic.
</td><td>
</td></tr>
<tr>
<td> Store a fraction of coeff factors where useful
</td><td> coeff_decimation
</td><td> The full set of twiddle factors can be generated from a smaller set, reducing BRAM use at the cost of the some logic.
</td><td>
</td></tr>
<tr>
<td> Generate coeffs with multipliers where useful
</td><td> coeff_generation
</td><td> Generate twiddle factors in the internal fft_direct block using an oscillator with feedback.
</td><td> To reduce BRAM usage =&gt; on. To reduce multiplier usage =&gt; off
</td></tr>
<tr>
<td> Number calibration locations when generating coeffs (2^?)
</td><td> cal_bits
</td><td> When generating twiddle factors with an oscillator with feedback, reference values are used to calibrate the complex exponential generated.
</td><td> For low BRAM usage =&gt; 1. For high quality twiddle factors =&gt; 9.
</td></tr>
<tr>
<td> Feedback rotation vector resolution
</td><td> n_bits_rotation
</td><td> When generating the twiddle factors, the resolution of the vector determines how much error accumulates.
</td><td> For low error =&gt; 25. For low BRAM usage =&gt; 18.
</td></tr>
<tr>
<td> Maximum fanout
</td><td> max_fanout
</td><td> The maximum fanout the twiddle factors are allowed to experience between where they are generated and when they are multiplied with the data stream. As the coefficients are shared, large fanout can occur which can affect maximum timing achievable. Decreasing the maximum fanout allowed should increase possible performance at the expense of some logic.
</td><td>
</td></tr>
<tr>
<td> Multiplier specification (0=core, 1=embedded, 2=behavioural) (left=1st stage)
</td><td> mult_spec
</td><td> Array of values allowing exact specification of how multipliers are implemented at each stage.
</td><td> 2 (behavioral HDL) for each stage
</td></tr>
<tr>
<td> Bit growth instead of shifting
</td><td> bit_growth
</td><td> Bit growth at every stage in the FFT can result in overflows which affect data quality. This can be prevented by dividing the data by two on the output of every stage, or by increasing the number of bits in the data stream by one bit. Shifting decreases the dynamic range and possible data quality whereas bit growth increases the resource requirements.
</td><td>
</td></tr>
<tr>
<td> Max bits to growth to
</td><td> max_bits
</td><td> The maximum number of bits to increase the data path to when the bit growth option is chosen. Shifting is used for FFT stages after this.
</td><td>
</td></tr>
<tr>
<td> Hardcode shift schedule
</td><td> hardcode_shifts
</td><td> When shifting to prevent overflow, use a fixed shifting schedule. This uses less logic and increases performance when compared to using a dynamic shift schedule.
</td><td>
</td></tr>
<tr>
<td> Shift schedule
</td><td> shift_schedule
</td><td> When using a fixed shift schedule, use the shift schedule specified. A '1' at position M in the array indicates a shift for the M'th FFT stage, a '0' indicates no shift.
</td><td>
</td></tr>
<tr>
<td> DSP48 adders in butterfly
</td><td> dsp48_adders
</td><td> The butterfly operation at each stage consists of two adders and two subtracters that can be implemented using DSP48 units instead of logic.
</td><td> on (enabled) to reduce logic used.
</td></tr>
</table>
<h2> <span class="mw-headline" id="Ports"> Ports </span></h2>
<table width="1500" border="1" cellpadding="3">
<tr>
<th> Port
</th><th> Dir
</th><th> Data Type
</th><th> Description
</th><th> Recommended Use
</th></tr>
<tr>
<td> sync
</td><td> in
</td><td> Boolean
</td><td> sync is used to indicate the last data word of a frame of input data. When the block is in asynchronous operating mode an active signal is aligned with en being active. When the block is in synchronous operating mode, a an active pulse is aligned with the clock cycle before the first valid data of a new input frame.
</td><td> Ensure the sync period complies with the memo describing correct use.
</td></tr>
<tr>
<td> shift
</td><td> in
</td><td> Unsigned
</td><td> Sets the shifting schedule through the FFT to prevent overflow.  Bit 0 specifies the behavior of stage 0, bit 1 of stage 1, and so on.
<p>If a stage is set to shift (with bit = 1), then every sample is divided by 2 at the output of that stage.
</p>
</td><td>
</td></tr>
<tr>
<td> in&lt;stream&gt;&lt;input&gt;
</td><td> in
</td><td> Signed consisting of one (Input Bit Width) width signals per input.
</td><td> The time-domain stream(s) to be channelised.
</td><td> Data amplitude should not exceed 0.5 (divide data by 2 pre-FFT)
</td></tr>
<tr>
<td> en
</td><td> in
</td><td> Boolean
</td><td> When asynchronous operation is chosen, this port indicates that valid input data is available on all input data ports.
</td><td>
</td></tr>
<tr>
<td> sync_out
</td><td> out
</td><td> Boolean
</td><td> Indicates that data out will be valid next clock cycle.
</td><td>
</td></tr>
<tr>
<td> out&lt;stream&gt;&lt;input&gt;
</td><td> out
</td><td> Inherited
</td><td> The frequency channels.
</td><td>
</td></tr>
<tr>
<td> of
</td><td> out
</td><td> Unsigned, one bit per input stream
</td><td> Indication of internal arithmetic overflow. Not time aligned with data. The most significant bit is the flag for input stream 0 etc.
</td><td>
</td></tr>
</table>
<h2> <span class="mw-headline" id="Description"> Description </span></h2>
<p>Computes the Fast Fourier Transform with <span class="texhtml">2<sup><i>N</i></sup></span> channels for time samples presented <span class="texhtml">2<sup><i>P</i></sup></span> at a time in parallel.  Uses a biplex FFT architecture under the hood which has been extended to handled time samples in parallel.  For <span class="texhtml"><i>P</i> = 0</span>, this block accepts two independent, parallel streams (labelled as pols) and computes the FFT of each independently (the biplex architecture provides this for free).  Data is output in normal frequency order, meaning that channel 0 (corresponding to DC) is output first, followed by channel 1, on up to channel <span class="texhtml">2<sup><i>N</i></sup> &minus; 1</span> (which can be interpreted as channel -1).  When multiple time samples are presented in parallel on the input, multiple frequency samples are output in parallel.
</p>